## Relational Algebra & Calculus
We use [[Relational Algebra]] and [[Relational Calculus]] to express the types of requests we want to perform on databases. 

A [[Relational Algebra]] expression is a *sequence of relational algebra operations*. 

## Relational Algebra

Unary operations:
- SELECT
- PROJECT
- RENAME
Relational Algebra Operations
- UNION
- INTERSECTION
- DIFFERENCE
- CARTESIAN PRODUCT

## Operations

[[Operations]] produce new relations. The result of an operation is a *new relation*, possibly formed from one or more *input* relations. The algebra is "closed", where all object in relational algebra are relations. 

[[Expressions]] are the result of a relational algebra expression, represents a database query or retrieval request. 

## Unary relational Operations

## SELECT Operation - $\sigma$(sigma)
$$\sigma_{<\text{selection condition}>(R)}$$
where \<selection condition> is applied independently to each individual tuple t in R

**Example:**
$\sigma_{\text{SALARY>30k}}(EMPLOYEE)$

## PROJECT Operation - $\pi$(pi)
$$\pi_{\text{<attribute list>}}(R)$$
SELECTS all attributes from attribute list in R. Discards other things. 

**Example:**
$\pi_{\text{LNAME, FNAME, SALARY}}(\text{EMPLOYEE})$

> [!Question] Is PROJECT Commutative?
> No. 

## Nesting Different Operators

We can nest operations by passing a function into another functions params like this:
$\pi_{\text{bdate}}(\sigma_{\text{Dno=3 OR Dno=5 OR Dno=7}}(\text{EMPLOYEE}))$

## RENAME Operation - $\rho$ (rho)
Renames attributes. It will rename every attribute, so we need to pass in every name in the order we want them to be, even if we are just changing one name. 

$\rho_S(R)$ changes relation name to s
$\rho_{\text{(n1,n2,n3,...)}}(R)$ changes column attribute names n1,n2,n3,...
$\rho_{\text{S(n1,n2,n3,...)}}(R)$ changes both

# Union, Intersection, Minus

These require two sets to conduct operations!

## Relational Algebra Operations from Set Theory

- UNION: R $\cup$ S
- INTERSECTION: R $\cap$ S
- DIFFERENCE: R - S
## Type Compatibility

R and S are type compatible if
1. They have the same number of attributes
2. The domains are corresponding attributes are type compatible

## UNION Operation - $\cup$

The result of R $\cup$ S is a relation that includes all tuples in R and S, not adding duplicates. Must be type compatible


## INTERSECTION Operation - $\cap$

The result of R $\cap$ S is a relation that only includes tuples that are present in R and S. Must be type compatible

## DIFFERENCE Operation

The result of R - S is a relation that includes all tuples in R but not in S. Must be type compatible

## CARTESIAN Operation - $X$ 

The cross product or cross join, combines tuples from two relations and creates an exhaustive list pairing where all attributes are included and every combination of attributes are rows. 

# JOIN Operation - $\bowtie$  

Inner join combines related tuples based on conditions. 

### THETA JOIN Operation - $R \bowtie_\theta S$ 

R $\bowtie_\theta$ S where $\theta$ can be any general boolean expression. 


### Other Variations of JOIN

Equijoin only = comparison operator used
Natural join denoted by * removes attribute in an equi-join condition*

### NATURAL JOIN Operation - $R * S$

Simpler equi-join. Combines all attributes of R, S. Joins attributes with the same name. Matching attributes are implicitly matched. 

### OUTER JOIN Operation - $R \bowtie_{\text{param}} S$

A joint that keeps all tuples in both left and/or right relations when no matching tuples are found

#### Left outer join



#### Right Outer Join



#### Full Outer Join



## Aggregate Functions



## Aggregate Function Operation without grouping



## Aggregate Functions with groups



## Aggregate Functions



## Query Trees



## Summary of Operations

SELECT
PROJECT
THETA JOIN
EQUIJOIN
NATURALJOIN
UNION
INTERSECTION
DIFFERENCE
CARTESIANPRODUCT